---
layout: post
title: "Пример использования HKD"
date: 2021-07-02 00:00:00
description: "Пример использования Higher Kinded Data из библиотеки OCDQuery"
---


Нашёл библиотечку OCDQuery с генерацией запросов на doobie по пользовательским
моделям данных. Сама библиотека выглядит заброшенной, а вот в документации
лежит сокровище — понятное описание проблематики и реализации паттерна Higher
Kinded Data для моделей сущностей из БД.

[https://scalalandio.github.io/ocdquery/#Initialidea](https://scalalandio.github.io/ocdquery/#Initialidea)

Проблема: часть колонок заполняются БД по заданным правилам (автоинкремент id,
например). Соответственно, они присутствуют в модели, которая из базы читается,
но бесполезны в той, которая в базу пишется. Ещё при накатывании миграций нужны
не значения полей, а названия соответствующих колонок.

Можно решать это отдельными моделями на каждый вариант использования, можно
накостылить `null/Option` на все колонки. А можно применить HKD.

Описываем кейс-класс, поля которого лежат в контейнерах, тип которых задаётся
при создании. Под каждый способ использования модели задаётся комбинация
контейнеров.

{% highlight scala %}
case class ColumnName(name: String)

type Id[A] = A // когда поле обязательно присутствует
type UnitF[A] = Unit // когда поле будет создано базой
type ColumnNameF[A] = ColumnName // для миграций

// F для пользовательских полей
// С для полей, управляемых базой
case class User[F[_], C[_]](id: C[String], name: F[String])

type UserSelect = User[Id, Id] // все поля будут присутствовать в модели
type UserInsert = User[Id, UnitF] // поля, управляемые базой, будут заполнены Unit
type UserColumns = User[ColumnNameF, ColumnNameF] // вместо всех полей будут экземпляры ColumnNames
{% endhighlight %}

Количество тайп-параметров и их комбинаций можно делать любое в зависимости от
сценариев использования данных. Главное не получить комбинаторный взрыв :)
