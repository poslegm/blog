---
layout: post
title: "Контекстные функции Scala 3"
date: 2020-04-10 00:00:00
description: "О контекстных функциях в Scala 3"
---

Adam Warski написал
[блогпост](https://blog.softwaremill.com/context-is-king-20f533474cb3) с
подробным разбором context functions из Scala 3. Если вкратце, это возможность
описать тип функции с implicit параметром. Например:

{% highlight scala %}
type Executable[T] = ExecutionContext ?=> Future[T]
{% endhighlight %}

Изначально я их воспринимал просто как возможность задавать красивые
тайп-алиасы, чтобы не писать постоянно `(implicit ec: ExecutionContext)`. Но
всё же это более мощный механизм, и Adam в своём посте это раскрывает.

У меня глаз зацепился за один из примеров применения — проброс соединения к БД
через методы для объединения их вызовов в одну транзакцию. То есть
использование некоего `Connected[IO[T]]` вместо `ConnectionIO[T]` из
[doobie](https://github.com/tpolecat/doobie).

Это даёт больше гибкости в коде, но пропадает одна из моих любимых особенностей
скаловых библиотек для работы с RDBMS: функции, обращающиеся к базе, оперируют
специфичной монадкой (`ConnectionIO`/`DBIO`), которая композится только с
себеподобными, и не позволяет без костылей вкорячить в транзакцию какой-нибудь
тормозной сайд-эффект. Разделять транзакционный код вокруг базы и внешние
эффекты приложения на уровне типов — это здорово и безопасно.
